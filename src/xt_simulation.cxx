#include "xt_simulation.hxx"



simXT::simXT(int HV, int nevents, int fileId, std::string primary, double momentum):
    fGas(NULL), fGeo(NULL), fCompE_field(NULL), fSensor_e(NULL), fMyCanvas(NULL), fPrimaryParticle(primary), fPrimaryMomentum(momentum)
{
        fFileId = fileId;
	fHV = HV;
	fNEvent = nevents;
	fSize_box = 147.42; //cm
	fMyCanvas = new TCanvas("xt", "XT relation");
	std::cout<<"Canvas created"<<std::endl;

	fFile_out = new TFile(Form("root/output_%d.root",fileId), "RECREATE");
	fTree_out = new TTree("t", "t");
	fTree_out->Branch("n_cls", &f_n_cls);
	fTree_out->Branch("e_cls", &f_e_cls);
	fTree_out->Branch("ec_dis", &f_ec_dis);
	fTree_out->Branch("Nt", &f_Nt);
	fTree_out->Branch("n_ele", &f_n_ele);
	fTree_out->Branch("edep", &f_edep);
	fTree_out->Branch("index_e", &f_index_e);
	fTree_out->Branch("DriftDistance", &f_DriftDistance);
	fTree_out->Branch("DriftTime", &f_DriftTime);
	fTree_out->Branch("t_wire", &f_t_wire);
	fTree_out->Branch("DOCA", &f_DOCA);
	fTree_out->Branch("Status", &f_Status);
	fTree_out->Branch("x0", &f_x0);
	fTree_out->Branch("y0", &f_y0);
	fTree_out->Branch("z0", &f_z0);
	fTree_out->Branch("t0", &f_t0);
	fTree_out->Branch("x1", &f_x1);
	fTree_out->Branch("y1", &f_y1);
	fTree_out->Branch("z1", &f_z1);
	fTree_out->Branch("t1", &f_t1);

}

simXT::~simXT(){

}

void simXT::SetupGas(std::string gasFile, std::string ionMobilityFile){
	fGas = new MediumMagboltz();
	const double pressure = 750.;
	const double temperature = 293.15;
	fGas->LoadGasFile(gasFile.data());
	fGas->LoadIonMobility(ionMobilityFile.data());
	fGas->Initialise(true);
	fGas->SetW(100.);
//	fGas->PrintGas();
        std::cout<<"W value is "<<fGas->GetW()<<std::endl;
}

void simXT::SetupGeo(std::string geoFile){
	fGeo= new GeometrySimple();

	TFile* f_geo = new TFile(geoFile.c_str(), "read");
	if(!f_geo) std::cerr<<"Can not find Geo file!"<<std::endl;
	TTree* t_geo = (TTree*)f_geo->Get("t");

	t_geo->SetBranchAddress("x", &wire_x);
	t_geo->SetBranchAddress("y", &wire_y);
	t_geo->SetBranchAddress("type", &wire_type);

	SolidBox* box = new SolidBox(0., 0., 0., 10., 10., fSize_box);
	fGeo->AddSolid(box,fGas);
	fGeo->PrintSolids();

	std::cout<<"\033[32m";
	std::cout<<fGeo->IsInside(-1., -1., -1.)<<std::endl;
	std::cout<<"\033[0m";

	fCompE_field = new ComponentAnalyticField();
	fCompE_field->SetGeometry(fGeo);
	fCompE_field->SetMedium(fGas);   //

	for(int i=0; i<t_geo->GetEntries(); i++){
		t_geo->GetEntry(i);
		if(wire_type == 0) fCompE_field->AddWire(wire_x, wire_y, d_field, fHV*wire_type, "field");
		if(wire_type == 1) fCompE_field->AddWire(wire_x, wire_y, d_sense, fHV*wire_type, "sense");
		// std::cout<<"added wire at "<<wire_x<<" "<<wire_y<<std::endl;
	}
	


        fCompE_field->AddReadout("sense");
	fCompE_field->SetMagneticField(0, 0, 0);

        f_geo->Close();
	std::cout<<"Set geometry for EM field"<<std::endl;

}

void simXT::SetupSensor(){
	const double tMin = 0.;
	const double tMax = 2.;
	const double tStep = 0.01;
	const int nSteps = (int)(tMax-tMin)/tStep;
        fSensor_e = new Sensor();
	fSensor_e->AddComponent(fCompE_field);
	fSensor_e->SetArea(-5., -5., -fSize_box/2, 5., 5., fSize_box/2);
	fSensor_e->AddElectrode(fCompE_field, "sense");
	fSensor_e->SetTimeWindow(0., tStep, nSteps);
}

void simXT::MakeTrack(int nTrack){
	clock_t tStart = clock();
	TrackHeed* track = new TrackHeed();    //Heed++ model
	//TrackPAI* track = new TrackPAI();        //PAI model
	AvalancheMicroscopic* drift = new AvalancheMicroscopic();              //Change model here to use MC or microscopic
	ViewCell* cellView = new ViewCell();
	ViewDrift* draw_drift = new ViewDrift();

	track->SetSensor(fSensor_e);
	track->SetParticle(fPrimaryParticle);
	track->SetMomentum(fPrimaryMomentum);
	track->EnableDebugging();
	track->EnablePlotting(draw_drift);

	track->EnableDeltaElectronTransport();       //Enable Secondary ionization
	std::cout<<track->GetEnergy()<<std::endl;

	drift->SetSensor(fSensor_e);
	drift->EnablePlotting(draw_drift);

        //loop over tracks
	for(int i=0; i<nTrack; i++){
		//define track starting point and direction
		double track_x = 0.; //gRandom->Uniform(-1., 1.);
		double track_y = 1.;
		double track_z = 0.;
		double track_t = 0.;
		double track_dx = 0.; //gRandom->Uniform(-1., 1.);
		double track_dy = -1.;
		double track_dz = 0.; //gRandom->Uniform(-1., 1.);
		track->NewTrack(track_x, track_y, track_z, track_t, track_dx, track_dy, track_dz);

	        std::cout<<track->GetEnergy()<<std::endl;
		std::cout<<"Track at W value of "<<track->GetW()<<" Getting clusters..."<<std::endl;
		//number of clusters in a track
		int n_cls = 0;
		//number of electrons in a track
		int Nt = 0;
		//cluster coordinates
		double xc = 0., yc = 0., zc = 0., tc = 0.;
		//number of electrons produced in a collision
		int nc = 0;
		//energy loss in a collision
		double ec = 0.;
		//total energy loss in a track
		double edep = 0.;
		//dummy variable
		double extra = 0.;
		//Get clusters generated by ionization
		while(track->GetCluster(xc, yc, zc, tc, nc, ec, extra)){        // Why not use references but normal variables?
			std::cout<<nc<<" electrons generated"<<std::endl;
			if(xc<-0.8||xc>0.8||yc<-0.8||yc>0.8) continue;              //Only use clusters in center cell
			n_cls++;
			Nt += nc;
			f_e_cls.push_back(ec);
			edep += ec;
			f_n_ele.push_back(nc);
			double del_x, del_y, del_z, del_t;
			double ke;
			int i_dummy;
			double dummy;
/*			//loop over electrons in one cluster
			for(int j=0; j<nc; j++){
				track->GetElectron(j, del_x, del_y, del_z, del_t, ke, dummy, dummy, dummy);
				//get distance between every electron and the first electron in the cluster
                                f_ec_dis.push_back( sqrt( pow(del_x-xc,2)+pow(del_y-yc,2)+pow(del_z-zc,2) ) );

				if(del_x<-0.8||del_x>0.8||del_y<-0.8||del_y>0.8) continue;       //avoid large cluster that electron exceed edge of cell
				drift->DriftElectron(del_x, del_y, del_z, del_t);
				size_t ne = drift->GetNumberOfElectronEndpoints();
				if(ne == 0) continue;            //Situation that electron of cluster is inside field wire                           
				if(ne >1){
					std::cout<<"\033[32m";
					std::cout<<ne<<" electrons !!!!"<<std::endl;
					std::cout<<"\033[0m";
					throw "ERROR!!!!!";
					double a = f_x0.at(-1);
				}
				//elecron starting and end points
				double x0 = 0., y0 = 0., z0 = 0., t0 = 0., x1 = 0., y1 = 0., z1 = 0., t1 = 0.;
				drift->GetElectronEndpoint(0, x0, y0, z0, t0, x1, y1, z1, t1, f_Status);
				//save starting and end points
				f_x0.push_back(x0);
				f_y0.push_back(y0);
				f_z0.push_back(z0);
				f_t0.push_back(t0);
				f_x1.push_back(x1);
				f_y1.push_back(y1);
				f_z1.push_back(z1);
				f_t1.push_back(t1);
				std::cout<<j<<" th electron at "<<x0<<" "<<y0<<" "<<z0<<std::endl;
			}*/
		}
/*		//Jump to next track if all clusters are out of cell
		//Case there is cluster in cell but no drift electrons f_t0.size() = 0 && f_ec_dis.size() != 0: 
		//eletron are generated inside field wire with 0 E field
		if(f_t0.size() == 0){ f_ec_dis.clear(); f_e_cls.clear(); f_n_ele.clear(); continue; }
*/		//save number of clusters in a track
		f_n_cls = n_cls;
		//
		f_Nt = Nt;
/*		//save total energy loss
		f_edep = edep;
		//Find the first electron that achieve the sense wire and calculate drift time and distance
		int pos = std::min_element(f_t1.begin(), f_t1.end()) - f_t1.begin();
		std::cout<<"position at "<<pos<<" in size "<<f_t1.size()<<std::endl;
		f_index_e = pos;
		f_DriftTime = f_t1.at(pos) - f_t0.at(pos);
		f_t_wire = f_t1.at(pos);                             //Timing of first-achieve-wire electron
		f_DriftDistance = sqrt( pow(f_x1.at(pos)-f_x0.at(pos),2) + pow(f_y1.at(pos)-f_y0.at(pos),2) + pow(f_z1.at(pos)-f_z0.at(pos),2) );
		//Calculate DOCA between track and sense wire
		TVector3 dir_wire(0.,0.,1.);
		TVector3 dir_trk(track_dx,track_dy,track_dz);
		TVector3 normal = dir_wire.Cross(dir_trk);
		normal = normal.Unit();
		TVector3 pos_trk(track_x,track_y,track_z);
		f_DOCA =  pos_trk * normal;
*/
		fTree_out->Fill();
		f_x0.clear();
		f_y0.clear();
		f_z0.clear();
		f_t0.clear();
		f_x1.clear();
		f_y1.clear();
		f_z1.clear();
		f_t1.clear();

		f_ec_dis.clear();
		f_e_cls.clear();
		f_n_ele.clear();

	}

	//Calculate simulation time for all track/drift/avalanche
	std::cout<<std::fixed<<std::setprecision(5)<<(double)(clock() - tStart)/CLOCKS_PER_SEC<<" s for simulating "<<nTrack<<" tracks"<<std::endl;
	
	//view drift
        /* cellView->SetCanvas(fMyCanvas);
	cellView->EnableWireMarkers();
        cellView->SetComponent(fCompE_field);
	cellView->SetArea(-3, -3, -fSize_box/2, 3, 3, fSize_box/2);
	cellView->Plot2d(); */

        /*draw_drift->SetCanvas(fMyCanvas);
	draw_drift->Plot(1,0);*/

	fFile_out->cd();
	fMyCanvas->Write();
	fTree_out->Write();
	fFile_out->Close();

}

void simXT::DrawField(){
	//Draw field lines
	ViewField* draw_field = new ViewField();
	draw_field->SetArea(-0.8, -0.8, -fSize_box/2, 0.8, 0.8, fSize_box);
	draw_field->SetComponent(fCompE_field);
	draw_field->SetSensor(fSensor_e);
	draw_field->SetCanvas(fMyCanvas);
	draw_field->SetNumberOfContours(10);
	draw_field->Plot("p", "CONT1Z");
}

int main(int argc, char** argv){

        std::cout<<argc<<" arguments"<<std::endl;
	if(argc<9){
		std::cout<<"/xt_simulation <gasfile><ionMobfile><geoFile><HV><number_events><fileId><particle><momentum[eV]>"<<std::endl;
		return 1;
	}
	std::string gasFile = argv[1];
	std::string ionMobFile = argv[2];
	std::string geoFile = argv[3];
	int hv = atoi(argv[4]);
	int nevents = atoi(argv[5]);
	int fileId = atoi(argv[6]);
	std::string primary_particle = argv[7];
	double primary_momentum = atof(argv[8]);
	TApplication app("app", &argc, argv);

	simXT *usercode = new simXT(hv, nevents, fileId, primary_particle, primary_momentum);

	usercode->SetupGas(gasFile, ionMobFile);
	usercode->SetupGeo(geoFile);
	usercode->DrawField();
	usercode->SetupSensor();
	usercode->MakeTrack(nevents);

	app.Run();
	
	return 0;
}
